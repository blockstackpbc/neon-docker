systemd:
  units:
    - name: getty@.service
      dropins:
        - name: no-disallocate.conf
          contents: |
            [Service]
            TTYVTDisallocate=no
    - name: clone_repo.service
      command: start
      content: |
        # clone_repo.service
        [Unit]
        Description=Checkout neon-docker Repo
        ConditionPathExists=!/bitcoind
        Before=docker.service
        Before=pull_repo.service

        [Service]
        Type=oneshot
        RemainAfterExit=yes
        ExecStart=/usr/bin/git clone -b master --single-branch https://github.com/blockstackpbc/neon-docker /bitcoind

        [Install]
        WantedBy=multi-user.target

    - name: create_docker_network.service
      command: start
      enable: true
      content: |
        # create_docker_network.service
        [Unit]
        Description=BTC Docker Network
        ConditionFileIsExecutable=/bitcoind/scripts/create_docker_network.sh
        Requires=docker.service
        Requires=clone_repo.service
        Before=bitcoin_core.service
        Before=haproxy.service
        After=docker.service


        [Service]
        TimeoutStartSec=0
        Type=oneshot
        RemainAfterExit=yes

        ExecStart=/bin/sh /bitcoind/scripts/create_docker_network.sh

        [Install]
        WantedBy=multi-user.target

    - name: pull_repo.service
      enable: false
      content: |
        # pull_repo.service
        [Unit]
        Description=Update bitcoin-docker Repo
        ConditionPathExists=/bitcoind
        Requires=clone_repo.service
        After=clone_repo.service

        [Service]
        Type=simple
        ExecStart=/usr/bin/git -C /bitcoind pull

        [Install]
        WantedBy=multi-user.target

    - name: pull_repo.timer
      command: start
      enable: true
      content: |
        # pull_repo.timer
        [Unit]
        Description=Execute git pull every hour

        [Timer]
        OnCalendar=*-*-* *:00:00
        Persistent=true

        [Install]
        WantedBy=multi-user.target

    - name: bitcoin_regtest.service
      command: start
      enable: true
      content: |
        # bitcoin_regtest.service
        [Unit]
        Description=BTC Regtest service
        Requires=docker.service
        Requires=create_docker_network.service
        Before=p2p_firewall.service
        Before=neon.service
        Before=nginx.service
        After=docker.service
        After=create_docker_network.service

        [Service]
        TimeoutStartSec=5
        Restart=always
        RemainAfterExit=yes
        RestartSec=5
        RuntimeDirectory=bitcoind
        PrivateTmp=true
        ProtectSystem=full
        NoNewPrivileges=true
        PrivateDevices=true

        ExecStartPre=-/usr/bin/docker stop bitcoin_regtest
        ExecStartPre=-/bin/sleep 1
        ExecStartPre=-/usr/bin/docker pull quay.io/blockstack/bitcoind:v0.20.99.0
        ExecStart=/usr/bin/docker run \
          --restart=always \
          --net=bitcoind \
          --ulimit nofile=90000:90000 \
          -p 28444:18444 \
          -p 28332:18332 \
          --expose 28332 \
          --expose 28444 \
          -e BTC_CONF=/etc/bitcoin/bitcoin.conf \
          -e BTC_DATA=/root/.bitcoin \
          -e BTC_PID=/run/bitcoind.pid \
          -v /bitcoind/configs/bitcoin/bitcoin-regtest.conf:/etc/bitcoin/bitcoin.conf \
          -v /data/bitcoin:/root/.bitcoin \
          --name bitcoin_regtest \
          quay.io/blockstack/bitcoind:v0.20.99.0 \
        /usr/local/bin/bitcoind -conf=/etc/bitcoin/bitcoin.conf -pid=/run/bitcoind.pid -datadir=/root/.bitcoin

        ExecStop=-/usr/bin/docker stop bitcoin_regtest
        ExecStopPost=-/usr/bin/docker rm -f bitcoin_regtest
        ExecReload=-/usr/bin/docker restart bitcoin_regtest

        # Deny the creation of writable and executable memory mappings.
        MemoryDenyWriteExecute=true

        [Install]
        WantedBy=multi-user.target

    - name: p2p_firewall.service
      command: start
      enable: true
      content: |
        # p2p_firewall.service
        [Unit]
        Description=P2P Firewall service
        After=docker.service
        After=bitcoin_regtest.service
        After=create_docker_network.service
        Requires=bitcoin_regtest.service
        Requires=create_docker_network.service


        [Service]
        TimeoutStartSec=0
        Restart=on-failure
        RuntimeDirectory=bitcoind
        PrivateTmp=true
        ProtectSystem=full
        NoNewPrivileges=true
        PrivateDevices=true

        ExecStartPre=-/usr/bin/docker stop p2p_firewall
        ExecStartPre=-/usr/bin/docker rm p2p_firewall
        ExecStartPre=-/usr/bin/docker pull quay.io/blockstack/bitcoind:p2p-firewall
        ExecStart=/usr/bin/docker run \
          --net=bitcoind \
          --ulimit nofile=90000:90000 \
          -p 18444:18444 \
          --expose 18444 \
          --name p2p_firewall \
          quay.io/blockstack/bitcoind:p2p-firewall \
        /usr/local/bin/bitcoin-p2p-firewalld -n regtest -b block,cmpctblock 18444 bitcoin_regtest.bitcoind:18444

        ExecStop=-/usr/bin/docker stop p2p_firewall
        ExecStopPost=-/usr/bin/docker rm -f p2p_firewall
        ExecReload=-/usr/bin/docker restart p2p_firewall

        # Deny the creation of writable and executable memory mappings.
        MemoryDenyWriteExecute=true

        [Install]
        WantedBy=multi-user.target

    - name: neon.service
      command: start
      enable: true
      content: |
        # neon.service
        [Unit]
        Description=Neon service
        After=docker.service
        After=bitcoin_regtest.service
        After=create_docker_network.service
        Requires=docker.service
        Requires=create_docker_network.service
        Requires=bitcoin_regtest.service

        [Service]
        TimeoutStartSec=0
        Restart=on-failure
        RuntimeDirectory=bitcoind
        PrivateTmp=true
        ProtectSystem=full
        NoNewPrivileges=true
        PrivateDevices=true

        ExecStartPre=-/usr/bin/docker stop neon
        ExecStartPre=-/usr/bin/docker rm neon
        ExecStartPre=-/usr/bin/docker pull quay.io/blockstack/bitcoind:neon
        ExecStart=/usr/bin/docker run \
          --net=bitcoind \
          --ulimit nofile=90000:90000 \
          -p 18443:18443 \
          --expose 18443 \
          -v /bitcoind/configs/bitcoin/neon-master-node.toml:/etc/neon-master-node/Config.toml \
          --name neon \
          quay.io/blockstack/bitcoind:neon \
        /usr/local/bin/bitcoin-neon-controller /etc/neon-master-node/Config.toml

        ExecStop=-/usr/bin/docker stop neon
        ExecStopPost=-/usr/bin/docker rm -f neon
        ExecReload=-/usr/bin/docker restart neon

        # Deny the creation of writable and executable memory mappings.
        MemoryDenyWriteExecute=true

        [Install]
        WantedBy=multi-user.target

    - name: nginx.service
      command: start
      enable: true
      content: |
        # nginx.service
        [Unit]
        Description=Nginx service
        After=docker.service
        After=bitcoin_regtest.service
        After=create_docker_network.service
        Requires=docker.service
        Requires=bitcoin_regtest.service
        Requires=create_docker_network.service


        [Service]
        TimeoutStartSec=0
        Restart=on-failure
        RuntimeDirectory=bitcoind
        PrivateTmp=true
        ProtectSystem=full
        NoNewPrivileges=true
        PrivateDevices=true

        ExecStartPre=-/usr/bin/docker stop nginx
        ExecStartPre=-/usr/bin/docker rm nginx
        ExecStartPre=-/usr/bin/docker pull quay.io/blockstack/bitcoind:nginx
        ExecStart=/usr/bin/docker run \
          --net=bitcoind \
          --ulimit nofile=90000:90000 \
          -p 80:80 \
          -p 443:443 \
          -p 18332:18332 \
          --expose 80 \
          --expose 443 \
          --expose 18332 \
          --name nginx \
          quay.io/blockstack/bitcoind:nginx \
        /usr/local/openresty/bin/openresty

        ExecStop=-/usr/bin/docker stop nginx
        ExecStopPost=-/usr/bin/docker rm -f nginx
        ExecReload=-/usr/bin/docker restart nginx

        # Deny the creation of writable and executable memory mappings.
        MemoryDenyWriteExecute=true

        [Install]
        WantedBy=multi-user.target

storage:
  directories:
    - path: /etc/sysctl.d
      filesystem: root
      user:
        name: root
      group:
        name: root
      mode: 0755
  files:
    - path: /etc/modules-load.d/nf.conf
      filesystem: root
      user:
        name: root
      group:
        name: root
      mode: 0644
      contents:
        inline: |
          nf_conntrack
    - path: /etc/sysctl.d/startup.conf
      filesystem: root
      user:
        name: root
      group:
        name: root
      mode: 0644
      contents:
        inline: |
          net.ipv4.conf.all.route_localnet=1
          fs.file-max=2097152

          # for es
          vm.max_map_count=262144
          # Allow for more PIDs
          kernel.pid_max=65535

          # Restrict core dumps
          fs.suid_dumpable=0

          # Hide exposed kernel pointers
          kernel.kptr_restrict=1

          # Do less swapping
          vm.swappiness=30
          vm.dirty_ratio=30
          vm.dirty_background_ratio=5

          # 50% overcommitment of available memory
          vm.overcommit_ratio=50
          vm.overcommit_memory=0

          # Keep at least 64MB of free RAM space available
          vm.min_free_kbytes=65535


          #Prevent SYN attack
          net.ipv4.tcp_syncookies=1
          net.ipv4.tcp_syn_retries=2
          net.ipv4.tcp_synack_retries=2
          net.ipv4.tcp_max_syn_backlog=4096

          # Enable IP spoofing protection, turn on source route verification
          net.ipv4.conf.all.rp_filter=1
          net.ipv4.conf.default.rp_filter=1

          # Disable ICMP Redirect Acceptance
          net.ipv4.conf.all.accept_redirects=0
          net.ipv4.conf.default.accept_redirects=0
          net.ipv4.conf.all.secure_redirects=0
          net.ipv4.conf.default.secure_redirects=0
          net.ipv6.conf.all.accept_redirects=0
          net.ipv6.conf.default.accept_redirects=0

          # Enable Log Spoofed Packets, Source Routed Packets, Redirect Packets
          net.ipv4.conf.all.log_martians=1
          net.ipv4.conf.default.log_martians=1

          # Decrease the time default value for tcp_fin_timeout connection
          net.ipv4.tcp_fin_timeout=7

          # Decrease the time default value for connections to keep alive
          net.ipv4.tcp_keepalive_time=300
          net.ipv4.tcp_keepalive_probes=5
          net.ipv4.tcp_keepalive_intvl=15

          # Don't relay bootp
          net.ipv4.conf.all.bootp_relay=0

          # Don't proxy arp for anyone
          net.ipv4.conf.all.proxy_arp=0

          # Turn on the tcp_timestamps, accurate timestamp make TCP congestion control algorithms work better
          net.ipv4.tcp_timestamps=1

          # Don't ignore directed pings
          net.ipv4.icmp_echo_ignore_all=0

          # Enable ignoring broadcasts request
          net.ipv4.icmp_echo_ignore_broadcasts=1

          # Enable bad error message Protection
          net.ipv4.icmp_ignore_bogus_error_responses=1

          # Enable a fix for RFC1337 - time-wait assassination hazards in TCP
          net.ipv4.tcp_rfc1337=1

          # For servers with tcp-heavy workloads, enable 'fq' queue management scheduler (kernel > 3.12)
          net.core.default_qdisc=fq

          # Turn on the tcp_window_scaling
          net.ipv4.tcp_window_scaling=1

          # Increase the read-buffer space allocatable
          net.ipv4.tcp_rmem=8192 87380 16777216
          net.ipv4.udp_rmem_min=16384
          net.core.rmem_default=262144
          net.core.rmem_max=16777216

          # Increase the write-buffer-space allocatable
          net.ipv4.tcp_wmem=8192 65536 16777216
          net.ipv4.udp_wmem_min=16384
          net.core.wmem_default=262144
          net.core.wmem_max=16777216

          # Increase number of incoming connections
          net.core.somaxconn=32768

          # Increase number of incoming connections backlog
          net.core.netdev_max_backlog=16384
          net.core.dev_weight=64

          # Increase the maximum amount of option memory buffers
          net.core.optmem_max=65535

          # Increase the tcp-time-wait buckets pool size to prevent simple DOS attacks
          net.ipv4.tcp_max_tw_buckets=1440000

          # try to reuse time-wait connections, but don't recycle them (recycle can break clients behind NAT)
          net.ipv4.tcp_tw_recycle=0
          net.ipv4.tcp_tw_reuse=1

          # Limit number of orphans, each orphan can eat up to 16M (max wmem) of unswappable memory
          net.ipv4.tcp_max_orphans=16384
          net.ipv4.tcp_orphan_retries=0

          # don't cache ssthresh from previous connection
          net.ipv4.tcp_no_metrics_save=1
          net.ipv4.tcp_moderate_rcvbuf=1

          # Increase size of RPC datagram queue length
          net.unix.max_dgram_qlen=50

          # Don't allow the arp table to become bigger than this
          net.ipv4.neigh.default.gc_thresh3=2048

          # Tell the gc when to become aggressive with arp table cleaning.
          # Adjust this based on size of the LAN. 1024 is suitable for most /24 networks
          net.ipv4.neigh.default.gc_thresh2=1024

          # Adjust where the gc will leave arp table alone - set to 32.
          net.ipv4.neigh.default.gc_thresh1=32

          # Adjust to arp table gc to clean-up more often
          net.ipv4.neigh.default.gc_interval=30

          # Increase TCP queue length
          net.ipv4.neigh.default.proxy_qlen=96
          net.ipv4.neigh.default.unres_qlen=6

          # Enable Explicit Congestion Notification (RFC 3168), disable it if it doesn't work for you
          net.ipv4.tcp_ecn=1
          net.ipv4.tcp_reordering=3

          # How many times to retry killing an alive TCP connection
          net.ipv4.tcp_retries2=15
          net.ipv4.tcp_retries1=3

          # Avoid falling back to slow start after a connection goes idle
          # keeps our cwnd large with the keep alive connections (kernel > 3.6)
          net.ipv4.tcp_slow_start_after_idle=0

          # Allow the TCP fastopen flag to be used, beware some firewalls do not like TFO! (kernel > 3.7)
          net.ipv4.tcp_fastopen=3

          # This will enusre that immediatly subsequent connections use the new values
          net.ipv4.route.flush=1
          net.ipv6.route.flush=1
